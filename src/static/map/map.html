<!DOCTYPE html>
<html>
  <head>
    <title>
      {{ fire_event_name }} - {{ burn_metric }} (DSE Burn Severity V0)
    </title>
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%221em%22 font-size=%2280%22>ðŸŒ¿</text></svg>"
    />
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Include Leaflet CSS -->
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.6.0/dist/leaflet.css"
    />

    <!-- Include Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.6.0/dist/leaflet-src.js"></script>

    <!-- Include the Leaflet Panel Layers CSS and JS files -->
    <link
      rel="stylesheet"
      href="/static/js/leaflet-panel-layers/src/leaflet-panel-layers.css"
    />
    <script src="/static/js/leaflet-panel-layers/src/leaflet-panel-layers.js"></script>

    <!-- Include MathJax -->
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script
      id="MathJax-script"
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
    ></script>

    <!-- Include noUiSlider JS -->
    <script src="https://cdn.jsdelivr.net/npm/nouislider@14.6.3/distribute/nouislider.min.js"></script>
    <link
      href="https://cdn.jsdelivr.net/npm/nouislider@14.6.3/distribute/nouislider.min.css"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/wnumb@1.2.0/wNumb.min.js"></script>
  </head>
  <style>
    /* TODO [#8]: Figure out sourcing for FastAPI served html */
    /* html, css, js, should obviously be seperate for legibility instead of spaghetti */

    .noUi-connects {
      height: 25px;
    }
    /* CSS to style the colored areas of the categorical slider to match map */
    #categorical-slider .noUi-connects .noUi-connect:nth-child(4) {
      background: rgb(255, 25, 25);
    }
    #categorical-slider .noUi-connects .noUi-connect:nth-child(3) {
      background: rgb(255, 100, 100);
    }
    #categorical-slider .noUi-connects .noUi-connect:nth-child(2) {
      background: rgb(255, 175, 175);
    }
    #categorical-slider .noUi-connects .noUi-connect:nth-child(1) {
      background: rgb(255, 250, 250);
    }

    /* CSS to style the colored areas of the continious slider to match map */
    #continuous-slider .noUi-connects .noUi-connect:nth-child(3) {
      background: rgb(255, 25, 25);
    }
    /* #continuous-slider .noUi-connects .noUi-connect:nth-child(2) {
        background: 
    } */
    #continuous-slider .noUi-connects .noUi-connect:nth-child(2) {
      background: linear-gradient(to top, rgb(255, 250, 250), rgb(255, 25, 25));
    }
    #continuous-slider .noUi-connects .noUi-connect:nth-child(1) {
      background: rgb(255, 250, 250);
    }

    /* Style for the map */
    #burn-map {
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      height: 100%;
      z-index: 0;
    }

    /* Style for the UI elements top right */
    #ui-elements-top-right {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 1000;
      padding: 10px;
      border-radius: 10px;
      background-color: #f0f0f0;
    }

    /* Style for the UI elements bottom left */
    #ui-elements-bottom-left {
      position: absolute;
      bottom: 10px;
      left: 60px;
      z-index: 1000;
      padding: 10px;
      border-radius: 10px;
      background-color: #f0f0f0;
    }

    /* Style for the UI elements bottom right */
    #ui-elements-bottom-right {
      position: absolute;
      bottom: 10px;
      right: 10px;
      z-index: 1000;
      padding: 10px;
      height: 60%;
      width: 15%;
      border-radius: 10px;
      background-color: #f0f0f0;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Style for the tooltip container */
    #tooltip-container {
      position: absolute;
      bottom: 10px;
      left: 10px;
      z-index: 1000;
      padding: 10px;
      border-radius: 10px;
      background-color: #f0f0f0;
    }

    /* Style for the tooltip divs */
    #tooltip-container div {
      padding: 10px;
    }

    /* Style for the highlighted metric */
    #tooltip-container div.highlighted {
      background-color: #ffe875;
    }

    #categorical-slider,
    #continuous-slider {
      height: 90%;
      float: left;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Style for the burn metric info div */
    .burn-metric-info {
      position: absolute;
      bottom: 10px;
      left: 10px;
      z-index: 1000;
      padding: 10px;
      border-radius: 10px;
      background-color: #f0f0f0;
    }
    .leaflet-panel-layers-list {
      width: 400px !important;
    }
  </style>
  <body>
    <div id="burn-map"></div>

    <!-- Top right ui elements -->
    <div id="ui-elements-top-right">
      <div id="burn-metric-info"></div>
    </div>

    <!-- Bottom right ui elements -->
    <!-- <div id="ui-elements-bottom-right"> -->
    <!-- Thresholds -->
    <!-- <div id="categorical-slider"></div> -->
    <!-- <div id="continuous-slider"></div> -->
    <!-- </div> -->

    <!-- Bottom left ui elements -->
    <!-- <div id="ui-elements-bottom-left">
      <label for="opacity-slider">Burn Severity Layer Opacity</label>
      <input
        type="range"
        min="0"
        max="1"
        step="0.1"
        value="1"
        id="opacity-slider"
      />
    </div> -->

    <script>
      // Data from Jinja2
      var burnMetric = "{{ burn_metric }}";
      var fireMetadata = JSON.parse({{fire_metadata_json | tojson | safe}});
      var fireBounds = [[fireMetadata.bounds[1], fireMetadata.bounds[0]], [fireMetadata.bounds[3], fireMetadata.bounds[2]]]
      var mapboxToken = "{{ mapbox_token }}"

      // Define the URLs for the Mapbox NAIP and Satellite layers
      var mapboxNaipUrl = 'https://api.mapbox.com/v4/mapbox.naip/{z}/{x}/{y}.png?access_token=' + mapboxToken;
      var mapboxSatelliteUrl = 'https://api.mapbox.com/v4/mapbox.satellite/{z}/{x}/{y}.png?access_token=' + mapboxToken;

      // Content for the webpage, defined as JSON
      var burnMetricText = JSON.parse('{{ burn_metric_text | tojson | safe }}');

      async function fetchData() {

          const boundaryResponse = await fetch('{{ burn_boundary_geojson_url | safe }}');
          const boundaryGeojson = await boundaryResponse.json();

          let ecoclassGeojson = null;
          const ecoclassResponse = await fetch('{{ ecoclass_geojson_url | safe }}');
          if (ecoclassResponse.status !== 404) {
            ecoclassGeojson= await ecoclassResponse.json();
          }

          let severityObsGeojson = null;
          const severityObsResponse = await fetch('{{ severity_obs_geojson_url | safe }}');
          if (severityObsResponse.status !== 404) {
            severityObsGeojson = await severityObsResponse.json();
          }

          return { boundaryGeojson, ecoclassGeojson, severityObsGeojson}; // Return the layers

      }

      fetchData().then(({ boundaryGeojson, ecoclassGeojson, severityObsGeojson }) => {

          var ecoclassLayer = L.geoJSON(ecoclassGeojson, {
              style: function(feature) {
                  return {
                      color: "#03420f",
                      weight: 1,
                      opacity: 1,
                      fillOpacity: 0
                  };
              },
              // onEachFeature: onEachEcoclass,
              pane: 'ecoclass'
          });

        if (severityObsGeojson) {
            var burnObsLayer = L.geoJSON(severityObsGeojson, {
                pointToLayer: function(feature, latlng) {
                    var severityFactor = feature.properties.SeverityFactor;
                    var color;

                    // Set color based on severity factor
                    if (severityFactor === 0) {
                        color = "#00FF00";
                    } else if (severityFactor === 1) {
                        color = "#FFFF00";
                    } else if (severityFactor === 2) {
                        color = "#FF9d00";
                    } else {
                        color = "#FF0000";
                    }

                    console.log(severityFactor, color); // Log the severity factor and color

                    return L.circleMarker(latlng, {
                        color: color,
                        weight: 6,
                        opacity: 1,
                        fillOpacity: 0
                    });
                },
                pane: 'burn-obs'
            });

          var obsLayers = {
              "Burn Severity": burnObsLayer
          }
        }

        if (ecoclassGeojson) {
            function createLayers(ecoclassGeojson, property1, property2, color) {
                var uniqueCombinations = [...new Set(ecoclassGeojson.features.map(feature => [feature.properties[property1], feature.properties[property2]].join(', ')))];
                var panelLayerList = [];
                uniqueCombinations.forEach(combination => {
                    var [item1, item2] = combination.split(', ');

                    // Skip if both are null or empty
                    if ((item1 === 'null' || item1 === '') && (item2 === 'null' || item2 === '')) {
                        return;
                    }

                    // Filter the ecoclassGeojson to only include the current combination
                    var geojson = {
                        type: "FeatureCollection",
                        features: ecoclassGeojson.features.filter(feature => feature.properties[property1] === item1 && feature.properties[property2] === item2)
                    };

                    // if item1 is not null, but item2 is null or blank, set item2 to (none)
                    if ((item1 !== 'null' && item1 !== '') && (item2 === 'null' || item2 === '')) {
                        item2 = '(none)';
                    }

                    var layer = L.geoJSON(geojson, {
                        style: function(feature) {
                            return {
                                color: color,
                                weight: 2,
                                opacity: .7,
                                fillOpacity: .5
                            };
                        },
                        pane: 'ecoclass'
                    });

                    // Add the layer to the object using the combination as the key, in the panel format
                    var panelLayer =  {
                        name: `${item1} - ${item2}`,
                        layer: layer
                    };

                    panelLayerList.push(panelLayer);
                });

                return panelLayerList;
            }

            var treeLayers = createLayers(ecoclassGeojson, 'dominantTree1', 'dominantTree2', "#048c1b");
            var shrubLayers = createLayers(ecoclassGeojson, 'dominantShrub1', 'dominantShrub2', "#f5b618");
            var herbLayers = createLayers(ecoclassGeojson, 'dominantHerb1', 'dominantHerb2', "#b339fa");
        }

          // Add GeoJSON layer for burn boundary
          var boundaryLayer = L.geoJSON(boundaryGeojson, {
              style: function(feature) {
                  return {
                      color: "#000000",
                      weight: 6,
                      opacity: 1,
                      fillOpacity: 0
                  };
              },
              pane: 'burn-boundary'
          });

          // Easy peasy Mapbox tileservers for the NAIP and Satellite layers
          var naipLayer = L.tileLayer(mapboxNaipUrl, {
              maxZoom: 20,
              pane: 'basemaps'
          });
          var satelliteLayer = L.tileLayer(mapboxSatelliteUrl, {
              maxZoom: 20,
              pane: 'basemaps'
          });

          // Add OSM Topo
          var openTopoLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
              attribution: 'Â© OpenStreetMap contributors',
              pane: 'basemaps'
          })

          // Add Rangeland Analysis Platform annuals
          var RapAnnualLayer = L.tileLayer('{{ rap_tileserver_annual_url | safe }}&algorithm=censor_and_scale&algorithm_params={"thresholds":{"min":"0","max":"1000"},"color":"blue"}', {
              maxZoom: 20,
              pane: 'metrics'
          })

            // Add Rangeland Analysis Platform perennials
          var RapPerennialLayer = L.tileLayer('{{ rap_tileserver_perennial_url | safe }}&algorithm=censor_and_scale&algorithm_params={"thresholds":{"min":"0","max":"1000"},"color":"blue"}', {
            maxZoom: 20,
            pane: 'metrics'
          })

          // Add Rangeland Analysis Platform shrubs
          var RapShrubLayer = L.tileLayer('{{ rap_tileserver_shrub_url | safe }}&algorithm=censor_and_scale&algorithm_params={"thresholds":{"min":"0","max":"1000"},"color":"blue"}', {
            maxZoom: 20,
            pane: 'metrics'
          })

          // Add Rangeland Analysis Platform trees
          var RapTreeLayer = L.tileLayer('{{ rap_tileserver_tree_url | safe }}&algorithm=censor_and_scale&algorithm_params={"thresholds":{"min":"0","max":"1000"},"color":"blue"}', {
              maxZoom: 20,
              pane: 'metrics'
          })

          // Create map
          var map = L.map('burn-map', {
              layers: [openTopoLayer, boundaryLayer],
              zoomControl: false
          })

            // Add zoom control
            L.control.zoom({
                position: 'bottomleft'
            }).addTo(map);

          // Create panes to properly order basemaps and metrics
          map.createPane('basemaps');
          map.getPane('basemaps').style.zIndex = 2;

          map.createPane('metrics');
          map.getPane('metrics').style.zIndex = 5;

          map.createPane('burn-boundary');
          map.getPane('burn-boundary').style.zIndex = 7;

          map.createPane('ecoclass');
          map.getPane('ecoclass').style.zIndex = 9;

          map.createPane('biomass');
          map.getPane('biomass').style.zIndex = 10;

          map.createPane('burn-obs');
          map.getPane('burn-obs').style.zIndex = 11;

          // Add layer controls - one for basemap, one for metrics
          var baseLayers = {
              "None": L.tileLayer('', {pane: 'basemaps'}), // Empty layer to remove all basemaps
              "OpenTopoMap": openTopoLayer,
              "NAIP": naipLayer,
              "Satellite": satelliteLayer
          };

          var polyLayers = {
              "Burn Boundary": boundaryLayer,
              "EDIT Ecological Classification": ecoclassLayer
          }

          var biomassLayers = {
              "Annual Biomass": RapAnnualLayer,
              "Perennial Biomass": RapPerennialLayer,
              "Shrub Biomass": RapShrubLayer,
              "Tree Biomass": RapTreeLayer
          }

          // Loading indicator
          var loadingDiv = L.DomUtil.create('div', 'loading');
          loadingDiv.innerHTML = 'Loading...';
          document.body.appendChild(loadingDiv);

          // Add event listeners to each layer
          for (var key in baseLayers) {
              if (key === 'None') {
                  continue;
              }
              baseLayers[key].setZIndex(2);
              baseLayers[key].on({
                  'loading': function() {
                      loadingDiv.style.display = 'block';
                  },
                  'load': function() {
                      loadingDiv.style.display = 'none';
                  }
              });
          }

        //   for (var key in metricsLayers) {
        //       metricsLayers[key].setZIndex(5);
        //       metricsLayers[key].on({
        //           'loading': function() {
        //               loadingDiv.style.display = 'block';
        //           },
        //           'load': function() {
        //               loadingDiv.style.display = 'none';
        //           }
        //       });
        //   }

          for (var key in polyLayers) {
              polyLayers[key].setZIndex(8);
              polyLayers[key].on({
                  'loading': function() {
                      loadingDiv.style.display = 'block';
                  },
                  'load': function() {
                      loadingDiv.style.display = 'none';
                  }
              });
          }

          for (var key in biomassLayers) {
              biomassLayers[key].setZIndex(10);
              biomassLayers[key].on({
                  'loading': function() {
                      loadingDiv.style.display = 'block';
                  },
                  'load': function() {
                      loadingDiv.style.display = 'none';
                  }
              });
          }

            var baseLayers = [
                {
                    name: "OpenTopoMap",
                    layer: openTopoLayer
                },
                {
                    name: "NAIP",
                    layer: naipLayer
                },
                {
                    name: "Satellite",
                    layer: satelliteLayer
                }
            ];


            console.log(treeLayers)

            var overLayers = [
                {
                    group: "Polygons",
                    layers: [
                        {
                            name: "Burn Boundary",
                            layer: boundaryLayer
                        },
                        {
                            name: "EDIT Ecological Classification",
                            layer: ecoclassLayer
                        }
                    ]
                },
                {
                    group: "EDIT Dominant Trees",
                    collapsed: true,
                    layers: treeLayers
                },
                {
                    group: "EDIT Dominant Shrubs",
                    collapsed: true,
                    layers: shrubLayers
                },
                {
                    group: "EDIT Dominant Herbs",
                    collapsed: true,
                    layers: herbLayers
                },
                {
                    group: "Rangeland Analysis Platform",
                    collapsed: true,
                    layers: [
                        {
                            name: "Annual Biomass",
                            layer: RapAnnualLayer
                        },
                        {
                            name: "Perennial Biomass",
                            layer: RapPerennialLayer
                        },
                        {
                            name: "Shrub Biomass",
                            layer: RapShrubLayer
                        },
                        {
                            name: "Tree Biomass",
                            layer: RapTreeLayer
                        }
                    ]
                },
                // Add more groups here
            ];

            // Create the panel layers control
            console.log("Creating panel layers", baseLayers)
            L.control.panelLayers(baseLayers, overLayers, {
                compact: false,
                collapsed: false,
                // autoZIndex: true,
                collapsibleGroups: true,
                position: 'topleft',
            }).addTo(map);

            // Add the burn metrics
            var metricLayers = [
                        {
                            name: "Continuous                                                        ",
                            slider: "continuous-slider",
                            layer: {
                                type: 'tileLayer',
                                args: [
                                    '{{ cog_tileserver_url_prefix | safe }}&algorithm=classify&algorithm_params={"thresholds":{"-0.025":250,"0.125":175,"0.250":100, "0.800":25}}',
                                    {
                                        maxZoom: 20,
                                        pane: 'metrics',
                                        opacity: 1
                                    }
                                ],
                            }
                        },
                        {
                            name: "Classifications",
                            slider: "categorical-slider",
                            layer: {
                                type: 'tileLayer',
                                args: [
                                    '{{ cog_tileserver_url_prefix | safe }}&algorithm=censor_and_scale&algorithm_params={"thresholds":{"min":"-0.400","max":"0.400"},"color":"red"}',
                                    {
                                        maxZoom: 20,
                                        pane: 'metrics',
                                        opacity: 1
                                    }
                                ],
                            }
                        }
                    ]

            console.log("Created panel layers", baseLayers, overLayers)
            console.log("Creating metric panel layers", metricLayers)

            var metricsPanel = L.control.panelLayers(null, metricLayers, {
                compact: false,
                collapsed: false,
                collapsibleGroups: false,
                position: 'bottomright',
                buildItem: function(layerItem) {
                    console.log("Building layer", layerItem)
                    var layer = layerItem.layer;
                    var name = layerItem.name;
                    var sliderType = layerItem.slider;

                    var parentDiv = document.createElement('div');
                    if (sliderType) {
                        console.log("Building sliders for layer", layer, name)
                        var opacitySliderDiv = document.createElement('div');
                        opacitySliderDiv.className = 'layer-slider';
                        opacitySliderDiv.style.height = '60px';

                        // Add "Opacity" label
                        var opacityLabel = document.createElement('label');
                        opacityLabel.htmlFor = sliderType;
                        opacityLabel.innerText = 'Opacity';
                        opacitySliderDiv.appendChild(opacityLabel);

                        // Create a new div element for the slider
                        noUiSlider.create(opacitySliderDiv, {
                            start: layer.options.opacity,
                            step: 0.01,
                            range: {
                                'min': 0.1,
                                'max': 1
                            }
                        });

                        opacitySliderDiv.noUiSlider.on('update', function(values, handle) {
                            layer.setOpacity(values[0]);
                        });

                        // Append the slider to the div
                        parentDiv.appendChild(opacitySliderDiv);

                        // Create a new div element for the slider
                        var breaksSliderDiv = document.createElement('div');
                        breaksSliderDiv.id = name + '-slider';

                        // Create a new noUiSlider on the div element
                        noUiSlider.create(breaksSliderDiv, {
                            start: [20, 80],
                            connect: true,
                            range: {
                                'min': 0,
                                'max': 100
                            }
                        });

                        // Add event listeners for slider updates
                        breaksSliderDiv.noUiSlider.on('update', function(values, handle) {
                            var url = layer._url;
                            var newUrl = url.replace(/"thresholds":{"-0.025":250,"0.125":175,"0.250":100, "0.800":25}/, '"thresholds":{"' + values[0] + '":250,"' + values[1] + '":175}');
                            layer.setUrl(newUrl);
                        });

                        // Append the slider to the div
                        parentDiv.appendChild(breaksSliderDiv);
                        // Set the div's innerText to the label

                        // Return the div element
                        return parentDiv;
                    } else {
                        // return empty node
                        return document.createElement('div');
                    }
                },
            })

            console.log("metricsPanel", metricsPanel)
            metricsPanel.addTo(map);
            metricsPanel.getContainer().id = 'controlMetrics';


        //   var opacitySlider = document.getElementById('opacity-slider');

        //   var updateOpacityClassified = function(e) {
        //       classifiedTileLayer.setOpacity(e.target.value);
        //   };
        //   var updateOpacityContinious = function(e) {
        //       continiousTileLayer.setOpacity(e.target.value);
        //   };

        //   opacitySlider.addEventListener('input', updateOpacityClassified);
        //   opacitySlider.addEventListener('input', updateOpacityContinious);

          // Iterate over each metric
          burnMetricInfo = document.getElementById('burn-metric-info');
          for (var key in burnMetricText) {
              // Create a div for the metric
              var div = document.createElement('div');

              // Add the metric name and formula
              div.innerHTML = '<strong>' + burnMetricText[key].metric_name + '</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="math">\\(' + burnMetricText[key].formula + '\\)</span>';

              // Add padding between divs
              div.style.padding = '10px';
              div.style.zIndex = 1000;

              // Highlight the current metric
              if (key.toLowerCase() === burnMetric.toLowerCase()) {
                  div.style.backgroundColor = '#ffe875';
              }

              // Append the div to the container
              burnMetricInfo.appendChild(div);

              // Ask MathJax to typeset the new div
              MathJax.typeset([div]);
          }

        //   // Add threshold sliders w/ noUiSlider
        //   var categoricalSlider = document.getElementById('categorical-slider');
        //   noUiSlider.create(categoricalSlider, {
        //       start: [-.025, .125, 0.250, 0.8],
        //       connect: [true, true, true, true, false],
        //       range: {
        //           'min': -.4,
        //           'max': .8
        //       },
        //       step: .025,
        //       direction: 'rtl',
        //       orientation: 'vertical',
        //       pips: {
        //           mode: 'steps',
        //           stepped: true,
        //           density: 16,
        //           format: wNumb({
        //               decimals: 2,
        //               to: function(value) {
        //                   // Convert to percentage from float
        //                   return (value * 100).toFixed(0) + '%';
        //               }
        //           }),
        //           filter: function(value, type) {
        //               return value % (4 * 0.025) === 0 ? 1 : -1;
        //           }
        //       },
        //       behaviour: 'tap-drag',
        //       tooltips: true,
        //       format: wNumb({
        //           decimals: 3
        //       }),
        //   });

        //   // Add continious slider w/ noUiSlider
        //   var continuousSlider = document.getElementById('continuous-slider');
        //   noUiSlider.create(continuousSlider, {
        //       start: [-.025, .4],
        //       connect: [true, true, true],
        //       range: {
        //           'min': -.4,
        //           'max': .8
        //       },
        //       step: .025,
        //       direction: 'rtl',
        //       orientation: 'vertical',
        //       pips: {
        //           mode: 'steps',
        //           stepped: true,
        //           density: 16,
        //           format: wNumb({
        //               decimals: 2,
        //               to: function(value) {
        //                   // Convert to percentage from float
        //                   return (value * 100).toFixed(0) + '%';
        //               }
        //           }),
        //           filter: function(value, type) {
        //               return value % (4 * 0.025) === 0 ? 1 : -1;
        //           }
        //       },
        //       behaviour: 'tap-drag',
        //       tooltips: true,
        //       format: wNumb({
        //           decimals: 3
        //       }),
        //   });
        //   // Initially hide the continuous slider
        //   continuousSlider.style.display = 'none';

        //   categoricalSlider.noUiSlider.on('update', function(values, handle) {
        //       var thresholds = {
        //           [values[0]]: 250,
        //           [values[1]]: 175,
        //           [values[2]]: 100,
        //           [values[3]]: 25
        //       };
        //       classifiedTileLayer.setUrl('{{ cog_tileserver_url_prefix | safe }}&algorithm=classify&algorithm_params=' + JSON.stringify({thresholds: thresholds}));
        //   });

        //   continuousSlider.noUiSlider.on('update', function(values, handle) {
        //       var thresholds = {
        //           min: values[0],
        //           max: values[1]
        //       };
        //       continiousTileLayer.setUrl('{{ cog_tileserver_url_prefix | safe }}&algorithm=censor_and_scale&algorithm_params=' + JSON.stringify({thresholds: thresholds}));
        //   });

        //   // Add event listeners to swich between categorical and continious sliders
        //   map.on('overlayadd', function(e) {
        //       if (e.name === 'Continuous') {
        //           // If the Continuous layer is added, hide the categorical slider and show the continuous slider
        //           categoricalSlider.style.display = 'none';
        //           continuousSlider.style.display = 'block';
        //       } else {
        //           categoricalSlider.style.display = 'block';
        //           continuousSlider.style.display = 'none';
        //       }
        //   });

          // Center map on fire, based on `bounds` metadata
          map.fitBounds(fireBounds);

      }).catch(error => console.error(error));
    </script>
  </body>
</html>
