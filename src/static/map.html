<!DOCTYPE html>
<html>
<head>
    <title>D3.js Map</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="https://d3js.org/d3-tile.v0.0.min.js"></script> 

    <style>
        path {
            stroke: #000;
            stroke-width: 1px;
            fill: #ddd;
        }

        .metric {
            fill: #700;
        }

        .tile {
            pointer-events: none;
            vector-effect: non-scaling-stroke;
        }
    </style>
</head>
<body>
  <script>
    var burnMetric = "{{ burn_metric }}";
    var fireMetadata = JSON.parse({{fire_metadata_json | tojson | safe}});
    var fireBounds = [[fireMetadata.bounds[1], fireMetadata.bounds[0]], [fireMetadata.bounds[3], fireMetadata.bounds[2]]]

    var width = 800;
    var height = 800;

    var svg = d3.select("body")
      .append("svg")
      .attr("width", width)
      .attr("height", height);

    var g = svg.append('g'); // Append 'g' element to svg

    // Create new tile layer
    var tile = d3.tile()
      .size([width, height]);

    // Define the zoom behavior
    var zoom = d3.zoom()
      .scaleExtent([1, 8]) // This controls how far you can zoom in and out
      .on('zoom', function() {
        svg.attr('transform', d3.event.transform);
        drawTiles(d3.event.transform); // Update tiles on zoom
      });

    svg.call(zoom);

    function drawTiles(transform) {
    var tiles = tile
        .scale(transform.k)
        .translate([transform.x, transform.y])
        ();

    var image = g
        .selectAll(".tile")
        .data(tiles, function(d) { return d; });

    image.exit().remove();

    image.enter().append("image")
        .attr("class", "tile")
        .attr("xlink:href", function(d) {
        var z = Math.round(Math.log(transform.k) / Math.LN2);
        var s = ['a', 'b', 'c'][Math.floor(Math.random() * 3)];
        return "https://" + s + ".tile.opentopomap.org/" + z + "/" + d[0] + "/" + d[1] + ".png";
        })
        .attr("x", function(d) { return (d[0] + tiles.translate[0]) * tiles.scale; })
        .attr("y", function(d) { return (d[1] + tiles.translate[1]) * tiles.scale; })
        .attr("width", tiles.scale)
        .attr("height", tiles.scale);
    }

    var initialTransform = d3.zoomIdentity
      .translate(width / 2, height / 2) // Center point
      .scale(1 << 13); // Zoom level (2^13)

    drawTiles(initialTransform); // Draw tiles initially

    Promise.all([
      d3.json('{{ burn_boundary_geojson_url | safe }}'), 
      d3.json('{{ ecoclass_geojson_url | safe }}'), 
    ])
    .then(([boundaryData, ecoclassData]) => {
        console.log(boundaryData);
        console.log(ecoclassData);

        // Calculate the center point of the boundary data
        var center = d3.geoCentroid(boundaryData);

        // Create a projection that centers on the centroid
        var projection = d3.geoMercator().center(center).fitSize([width, height], boundaryData);

        // Create a path generator with this projection
        var path = d3.geoPath().projection(projection);

        // Calculate the initial scale and translate parameters based on this projection
        var initialScale = projection.scale();
        var initialTranslate = projection.translate();

        // Set the initial transform
        var initialTransform = d3.zoomIdentity.translate(initialTranslate[0], initialTranslate[1]).scale(initialScale);

        // Draw tiles initially
        drawTiles(initialTransform);

        svg.selectAll("path")
            .data(ecoclassData.features)
            .enter().append("path")
            .attr("d", path)
            .attr("class", function (d) {
            return d.properties.ecoclass ? 'metric' : null;
        });

        svg.selectAll(".boundary")
            .data(boundaryData.features)
            .enter().append("path")
            .attr("d", path)
            .attr("class", "boundary");
    });
  </script>
</body>
</html>