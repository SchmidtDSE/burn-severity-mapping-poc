<!DOCTYPE html>
<html>
<head>
    <title>D3.js Map</title>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://d3js.org/topojson.v3.min.js"></script>
    <script src="https://d3js.org/d3-tile.v0.0.min.js"></script> 

    <style>
        path {
            stroke: #000;
            stroke-width: 1px;
            fill: #ddd;
        }

        .metric {
            fill: #700;
        }

        .tile {
            pointer-events: none;
            vector-effect: non-scaling-stroke;
        }
    </style>
</head>
<body>
  <script>
    var burnMetric = "{{ burn_metric }}";
    var fireMetadata = JSON.parse({{fire_metadata_json | tojson | safe}});
    var fireBounds = [[fireMetadata.bounds[1], fireMetadata.bounds[0]], [fireMetadata.bounds[3], fireMetadata.bounds[2]]]

    var width = 800;
    var height = 800;

    var svg = d3.select("body")
      .append("svg")
      .attr("width", width)
      .attr("height", height);

    var g = svg.append('g'); // Append 'g' element to svg

    // Create new tile layer
    var tileLayer = d3.tile()
        .size([width, height]);

    const tiler = d3.tile()
        .size([width, height]);

    const tileGroup = svg.append("g")
        .attr("pointer-events", "none");

        // Define the zoom behavior
    var zoom = d3.zoom()
      .scaleExtent([1, 8]) // This controls how far you can zoom in and out
      .on('zoom', function() {
        svg.attr('transform', d3.event.transform);
        drawTiles(d3.event.transform); // Update tiles on zoom
      });

    let tile = tileGroup.selectAll("g");

    svg.call(zoom);

    function drawTiles(transform) {
        const tiles = tiler(transform);

        tileGroup.attr("transform", `
            scale(${tiles.scale})
            translate(${tiles.translate.join(",")})
        `);

        tile = tile.data(tiles, d => d).join(
            enter => enter.append("g")
                .attr("transform", ([x, y]) => `translate(${x}, ${y}) scale(${1 / 256})`)
                .call(g => g.append("image")
                    .attr("xlink:href", d => `https://tile.openstreetmap.org/${d[2]}/${d[0]}/${d[1]}.png`)
                    .attr("width", 256)
                    .attr("height", 256))
        );
    }

    var initialTransform = d3.zoomIdentity
      .translate(width / 2, height / 2) // Center point
      .scale(1 << 13); // Zoom level (2^13)

    drawTiles(initialTransform); // Draw tiles initially

    Promise.all([
      d3.json('{{ burn_boundary_geojson_url | safe }}'), 
      d3.json('{{ ecoclass_geojson_url | safe }}'), 
    ])
    .then(([boundaryData, ecoclassData]) => {
        console.log(boundaryData);
        console.log(ecoclassData);

        // Calculate the center point of the boundary data
        var center = d3.geoCentroid(boundaryData);

        // Create a projection that centers on the centroid
        var projection = d3.geoMercator().center(center).fitSize([width, height], boundaryData);

        // Create a path generator with this projection
        var path = d3.geoPath().projection(projection);

        // Calculate the initial scale and translate parameters based on this projection
        var initialScale = projection.scale();
        var initialTranslate = projection.translate();

        // Set the initial transform
        var initialTransform = d3.zoomIdentity.translate(initialTranslate[0], initialTranslate[1]).scale(initialScale);

        // Draw tiles initially
        drawTiles(initialTransform);

        svg.selectAll("path")
            .data(ecoclassData.features)
            .enter().append("path")
            .attr("d", path)
            .attr("class", function (d) {
            return d.properties.ecoclass ? 'metric' : null;
        });

        svg.selectAll(".boundary")
            .data(boundaryData.features)
            .enter().append("path")
            .attr("d", path)
            .attr("class", "boundary");
    });
  </script>
</body>
</html>